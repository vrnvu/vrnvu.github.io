<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Types of Coroutines - ar (nau)</title>
    <link rel="stylesheet" href="../index.css">
    <link rel="stylesheet" href="../post.css">
</head>

<body>
    <div class="container">
        <nav>
            <a href="../index.html" class="back-button">‚Üê Back</a>
            <button id="theme-toggle">Dark Mode</button>
        </nav>
        <article>
            <h1>types of coroutines</h1>
            <div class="post-meta">
                <span class="date">2023-04-20</span>
                <span class="category">programming</span>
            </div>
            <div class="post-content">
                <p>Coroutines have been used in programming since 1958 and were defined by Knuth as a way to generalize
                    a subroutine. While regular subroutines start at the beginning and end at the end, coroutines can
                    pause their execution and resume later from where they left off. An explanation of this can be found
                    <a href="what-is-async.html">here</a>.
                </p>

                <p>The topic is complex because we normally mix "what a coroutine is" with "how it is going to run".</p>

                <h2>How</h2>

                <p>There are two common ways to use coroutines:</p>

                <ul>
                    <li><strong>stackless</strong>, where the code is transformed into a state machine by the compiler.
                    </li>
                    <li><strong>stackful</strong>, also known as fibers, which are user-mode threads that run on top of
                        a regular operating system thread.</li>
                </ul>

                <h2>What</h2>

                <p>We can identify two types of coroutines based on their need for a stack:</p>

                <ul>
                    <li><strong>stackless</strong>, only require a stack while the coroutine is running. Once the
                        coroutine suspends, its local variables can be serialized into a fixed-size structure, and the
                        current call stack can be used for executing the next coroutine.</li>
                    <li><strong>stackful</strong>, allows you to suspend your coroutines at any point, providing more
                        flexibility than stackless coroutines.</li>
                </ul>

                <p>The lack of a stack is what allows the compiler to transform and use a stackless coroutine, while the
                    need for a stack requires a runtime.</p>

                <h2>Conclusion</h2>

                <p>When you use async/await in your code, the compiler generates a state machine that will be executed
                    later. This approach is possible because async/await only suspends execution at predetermined
                    points,
                    eliminating the need for a stack to track progress. The compiler can transform your code into a
                    state
                    machine that preserves the state of local variables and resumes execution from where it left off.
                </p>

                <p>In contrast, when using goroutines, fibers, or green threads, you can suspend and resume execution
                    at any point in the code. This flexibility necessitates a stack to keep track of the execution
                    state.
                    These types of coroutines also require a runtime environment capable of managing the stacks and
                    scheduling the coroutines across available threads.</p>
            </div>
        </article>
    </div>

    <script>
        document.getElementById('theme-toggle').addEventListener('click', function () {
            document.body.classList.toggle('dark-mode');
            this.textContent = document.body.classList.contains('dark-mode') ? 'Light Mode' : 'Dark Mode';
        });
    </script>
</body>

</html>