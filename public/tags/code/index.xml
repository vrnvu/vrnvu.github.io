<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Code on zaunaidar</title>
    <link>http://localhost:1313/tags/code/</link>
    <description>Recent content in Code on zaunaidar</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 22 Oct 2021 17:12:11 +0700</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/code/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>design is not a senior priviliege</title>
      <link>http://localhost:1313/posts/design-is-not-senior/</link>
      <pubDate>Fri, 22 Oct 2021 17:12:11 +0700</pubDate>
      <guid>http://localhost:1313/posts/design-is-not-senior/</guid>
      <description>&lt;p&gt;Some teams treat architecture as a separate role reserved for &amp;ldquo;senior&amp;rdquo; engineers. They draw the diagrams, make the decisions, and pass the work.&lt;/p&gt;&#xA;&lt;p&gt;This separation &lt;strong&gt;is a problem&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Design isn&amp;rsquo;t a reward for experience. It&amp;rsquo;s a skill that improves with practice, not just time. Like any skill, it should be part of the job from the start.&lt;/p&gt;&#xA;&lt;h3 id=&#34;you-grow-by-doing&#34;&gt;You grow by doing&lt;/h3&gt;&#xA;&lt;p&gt;You don&amp;rsquo;t learn implementation all at once. You start small: an endpoint, a form, a script. Later, you take on a bigger piece: auth, infra, data flows. Eventually, you ship whole services, across teams or markets.&lt;/p&gt;</description>
    </item>
    <item>
      <title>dev log</title>
      <link>http://localhost:1313/posts/dev-log/</link>
      <pubDate>Fri, 22 Oct 2021 17:12:11 +0700</pubDate>
      <guid>http://localhost:1313/posts/dev-log/</guid>
      <description>&lt;p&gt;This year I started a development log for my work notes. It made me far more effective. I control my work, measure my impact, and keep visibility on what I am doing and with whom.&lt;/p&gt;&#xA;&lt;p&gt;Tools support the method. Pick one you will use consistently; the method drives results.&lt;/p&gt;&#xA;&lt;p&gt;Remember:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Use tools and adapt them so they feel natural.&lt;/li&gt;&#xA;&lt;li&gt;Simple and easy beats complex and hard.&lt;/li&gt;&#xA;&lt;li&gt;Clarity beats volume.&lt;/li&gt;&#xA;&lt;li&gt;Use references for easy and fast navigation.&lt;/li&gt;&#xA;&lt;li&gt;Keep your notes structured and easy to search.&lt;/li&gt;&#xA;&lt;li&gt;A note is useful if it moves a decision, an action, or a result.&lt;/li&gt;&#xA;&lt;li&gt;A note is useful if you can share it with somebody else.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;structure&#34;&gt;Structure&lt;/h2&gt;&#xA;&lt;p&gt;I use Apple Notes. It is simple. It supports tags, search, and note references. It syncs with my work phone and, most importantly, it works for me.&lt;/p&gt;</description>
    </item>
    <item>
      <title>invariants</title>
      <link>http://localhost:1313/posts/invariants/</link>
      <pubDate>Fri, 22 Oct 2021 17:12:11 +0700</pubDate>
      <guid>http://localhost:1313/posts/invariants/</guid>
      <description>&lt;h1 id=&#34;making-impossible-states-impossible&#34;&gt;making impossible states impossible&lt;/h1&gt;&#xA;&lt;p&gt;Last week, a race condition crashed production at 3 AM. The bug was impossible to reproduce in development, but a single assertion would have caught it immediately. This is why assertions exist: they make impossible states impossible.&lt;/p&gt;&#xA;&lt;p&gt;Some developers think assertions are just debugging tools. Not true. Assertions are contracts that prevent your code from reaching invalid states. Without assertions, bugs hide in impossible states. With assertions, impossible states become impossible. When combined with good &lt;a href=&#34;https://arnau.bearblog.dev/this-is-ci/&#34;&gt;CI&lt;/a&gt;, every change becomes visible, every assumption gets tested, and every deployment becomes predictable. As &lt;a href=&#34;https://typesanitizer.com/blog/assertions.html&#34;&gt;this analysis&lt;/a&gt; shows, assertions are crucial for catching correctness violations that types cannot prevent.&lt;/p&gt;</description>
    </item>
    <item>
      <title>snapshots, property and simulation testing</title>
      <link>http://localhost:1313/posts/snapshots/</link>
      <pubDate>Fri, 22 Oct 2021 17:12:11 +0700</pubDate>
      <guid>http://localhost:1313/posts/snapshots/</guid>
      <description>&lt;p&gt;Your test suite passes. Your coverage is 90%. You deploy to production. Your software breaks.&lt;/p&gt;&#xA;&lt;p&gt;Traditional testing measures the wrong things. It counts lines of code covered, not bugs prevented. It tests components in isolation, not how they interact in the real world. It catches the bugs you expect, not the ones that actually matter.&lt;/p&gt;&#xA;&lt;p&gt;You ship correctness bugs that unit tests never catch. The best way to avoid bugs is to &lt;a href=&#34;https://www.teamten.com/lawrence/programming/dont-write-bugs.html&#34;&gt;not write them in the first place&lt;/a&gt;—but when you do, you need tests that actually catch them.&lt;/p&gt;</description>
    </item>
    <item>
      <title>this is ci</title>
      <link>http://localhost:1313/posts/this-is-ci/</link>
      <pubDate>Fri, 22 Oct 2021 17:12:11 +0700</pubDate>
      <guid>http://localhost:1313/posts/this-is-ci/</guid>
      <description>&lt;p&gt;Last month, a developer updated a library version. The application worked fine in development, but production crashed at 2 AM. The deployment pipeline had passed all tests—but it hadn&amp;rsquo;t tested the actual change. This is why most CI fails: it tests code, not changes. When CI fails, production breaks, teams lose trust, and changes become dangerous.&lt;/p&gt;&#xA;&lt;p&gt;Most teams think CI is about running tests on GitHub. They&amp;rsquo;re wrong. CI is about correctness and detecting changes automatically. We test to have correct code and detect changes, and CI is that process being &lt;a href=&#34;https://graydon2.dreamwidth.org/1597.html&#34;&gt;continuous&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>visibility and collaboration</title>
      <link>http://localhost:1313/posts/visibility-collaboration/</link>
      <pubDate>Fri, 22 Oct 2021 17:12:11 +0700</pubDate>
      <guid>http://localhost:1313/posts/visibility-collaboration/</guid>
      <description>&lt;p&gt;Software engineering requires &lt;strong&gt;collaboration&lt;/strong&gt; by nature.&lt;/p&gt;&#xA;&lt;p&gt;Consider the classic split: one engineer builds the backend while another builds the frontend. They can work in parallel, but only if they know what each other is doing and they know what to do. The moment they don&amp;rsquo;t, progress slows.&lt;/p&gt;&#xA;&lt;p&gt;Two methods address this. Management-enforced process with agile techniques like daily standups and bureaucracy. Or software engineering culture born from the team itself. They serve different goals. Management wants visibility to control, monitor and &amp;ldquo;check in.&amp;rdquo; Good software engineers want to get the work done and do it well. The latter is the foundation of good team culture.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
