<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="light dark" name=color-scheme><title>elements of programming</title><meta content="<hr />
<p>Elements of programming style. (1974)</p>
<p>Brian Kernighan and P.J Plauger</p>
" name=description><link href=/img/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/img/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/img/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=https://fonts.googleapis.com rel=preconnect><link href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&family=Jost&display=swap" rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css rel=stylesheet><link href=/css/var.css rel=stylesheet><link href=/css/base.css rel=stylesheet><link href=/css/header.css rel=stylesheet><link href=/css/footer.css rel=stylesheet><link href=/css/post.css rel=stylesheet><body><script>if(localStorage.getItem('theme')=='dark'){document.body.classList.add('dark-mode');}</script><header class=blur><div class=top><a class="header blog" href=/blog><i class="ri-terminal-box-line ri-2x"></i><span>Blog</span></a><a class=back href=/><i class="ri-arrow-left-s-line ri-1x"></i><span>Home</span></a><div class=icon><a aria-label=home href=/ id=go-home><i class="ri-user-6-line ri-xl"></i></a><a aria-label="rss feed" href=/blog/feed.xml><i class="ri-rss-line ri-xl"></i></a><button aria-label="dark light mode switch" id=color-toggle><i class="ri-moon-line ri-xl"></i></button><button aria-label="table of content" id=toc-toggle><i class="ri-menu-2-line ri-xl"></i></button></div></div><div id=progress-bar></div></header><div class=wrap><div class=blank></div><main><div id=top></div><article><h1>elements of programming</h1><div id=post-info><div class=date><span id=publish>2020-12-01</span></div><div class=tags><a class=tag href=https://arnaudiaz.com/tags/programming><i class="ri-hashtag ri-sm"></i><span>programming</span></a></div></div><hr><p>Elements of programming style. (1974)<p>Brian Kernighan and P.J Plauger</p><span id=continue-reading></span><h1 id=introduction>Introduction</h1><ul><li><strong>Write clearly - don't be to clever.</strong></ul><h1 id=expression>Expression</h1><ul><li><p><strong>Say what you mean, simply and directly.</strong> Explicit. Intention.</p><li><p><strong>Use library functions.</strong> Don't re-invent the wheel. Copy. Even better. Steal. Good artist copy, genius steal.</p><li><p><strong>Avoid temporary variables.</strong> Avoid mutable data structures when it makes sense.</p><li><p><strong>Write clearly - don't sacrifice clarity for "efficiency".</strong> Benchmark.</p><li><p><strong>Let the machine do the dirty work.</strong> Computers are fast. More than you think.</p><li><p><strong>Replace repetitive expressions by calls to a common function.</strong> But don't add abstractions you won't need.</p><li><p><strong>Parenthesize to avoid ambiguity.</strong> Rename, rewrite.</p><li><p><strong>Choose variable names that won't be confused.</strong></p><li><p><strong>Avoid unnecessary branches.</strong> Algorithmic design code smell.</p><li><p><strong>Use the good features of a language; avoid the bad ones.</strong> Use the right tool for the job. Don't use conditional branches as a substitue for a logical expression. Think in expressions. Write with expressions. Always.</p></ul><h1 id=control-structure>Control structure</h1><ul><li><p><strong>Delimit group of statements.</strong> Consisteny.</p><li><p><strong>Use IF-ELSE to emphasize that only one of two actions is to be performed.</strong></p><li><p><strong>Use DO and DO-WHILE to emphasize the presence of loops.</strong></p><li><p><strong>Make your programs read from top to bottom.</strong></p><li><p><strong>Use the fundamental control flow constructs.</strong></p><li><p><strong>Write first in an easy-to-understand pseudo-language; then translate into whatever language you have to use.</strong> Paper first.</p><li><p><strong>Avoid THEN-IF and null ELSE.</strong></p><li><p><strong>Avoid ELSE GOTO and ELSE RETURN.</strong></p><li><p><strong>Follow each decision as closely as opssible with its associated action.</strong></p><li><p><strong>Use data arrays to avoid repetitive control sequences.</strong></p><li><p><strong>Choose a data representation that makes the program simple.</strong> Data oriented programming. Data first. Data moves your code.</p><li><p><strong>Don't stop with your first draft.</strong> Forth philosophy. Thinking Forth.</p></ul><h1 id=program-structure>Program structure</h1><ul><li><p><strong>Modularize. Use subroutines.</strong> Write cohesive. Build languages. Extend your program as needed.</p><li><p><strong>Make the coupling between modules visible.</strong> Port. Adapter.</p><li><p><strong>Each module should do one thing well.</strong> One thing.</p><li><p><strong>Make sure every module hides something.</strong> It's not about what you hide. It's more about what rules you expose. An interface is a contract.</p><li><p><strong>Let the data structure the program.</strong></p></ul><p>Data first.<ul><li><p><strong>Don't patch bad code - rewrite it.</strong> Opportunistic programming. A program evolves. Always keep it in mind.</p><li><p><strong>Write and test a big program in small pieces.</strong> You don't write test to check if it works. You write it assert it won't break.</p><li><p><strong>Use recursive procedures for recursively-defined data structures.</strong></p></ul><h1 id=input-and-output>Input and output</h1><ul><li><p><strong>Test input for validity and plausiblity</strong> Don't validate. Parse. Use your type system.</p><li><p><strong>Make sure input cannot violate the limits of the program.</strong></p><li><p><strong>Terminate input by end-of-file or marker, not by count.</strong></p><li><p><strong>Identify bad input; recover if possible.</strong> If your code can recover it's well written.</p><li><p><strong>Treat end of file conditions in a uniform manner.</strong></p><li><p><strong>Make input easy to prepare and output self-explanatory.</strong></p><li><p><strong>Use uniform input formats.</strong></p><li><p><strong>Make input easy to proofread.</strong></p><li><p><strong>Use self-identifying input. Allow defaults. Echo both on output.</strong></p><li><p><strong>Localize input and output in subroutines.</strong> Limit side effects in the process.</p></ul><h1 id=common-blunders>Common blunders</h1><ul><li><p><strong>Make sure all variables are initialized before use.</strong></p><li><p><strong>Don't stop at one bug.</strong></p><li><p><strong>Use debuggin compilers.</strong> Invest in your environment.</p><li><p><strong>Initialize constants with DATA statements or INITIAL attributes; initialize variable with executable code.</strong></p><li><p><strong>Watch out for off-by-one errors.</strong></p><li><p><strong>Take care to branch the right way on equality.</strong></p><li><p><strong>Avoid multiple exits from loops.</strong> Algorithmic design code smell.</p><li><p><strong>Make sure your code "does nothing" gracefully.</strong></p><li><p><strong>Test programs at their boundary values.</strong></p><li><p><strong>Program defensively.</strong></p><li><p><strong>10.0 times 0.1 is hardly ever 1.0.</strong></p></ul><h1 id=efficiency>Efficiency</h1><ul><li><p><strong>Make it right before you make it faster.</strong> You probably won't ever need to make everything faster.</p><li><p><strong>Keep it right when you make it faster.</strong></p><li><p><strong>Make it clear before you make it faster.</strong> Requirements will change anyway.</p><li><p><strong>Don't sacrifice clarity for small gains in "efficiency".</strong> You don't even know what a GC is.</p><li><p><strong>Let your compiler do the simple optimizations.</strong> Help the compiler. Smaller chunks of code usually help.</p><li><p><strong>Don't strain to re-use code; reorganize instead.</strong> Don't add complexity. Don't add unnecesarry abstractions.</p><li><p><strong>Make sure special cases are truly special.</strong></p><li><p><strong>Keep it simple to make it faster.</strong></p><li><p><strong>Don't diddle code to make it faster - find a better algorithm.</strong> Algorithmic design code smell.</p><li><p><strong>Instrument your programs. Measure before makign "efficiency" changes.</strong> Code so it's easy to test. Code so it's easy to benchmark.</p></ul><h1 id=documentation>Documentation</h1><ul><li><p><strong>Make sure comments and code agree.</strong> Use your type system. Use auto generated docs.</p><li><p><strong>Make every comment count.</strong></p><li><p><strong>Don't comment bad code. Rewrite it.</strong></p><li><p><strong>Use variable names that mean something.</strong></p><li><p><strong>Format a program to help a reader understand it.</strong> Explain the why.</p><li><p><strong>Indent to show the logical structure of a program.</strong></p><li><p><strong>Document your data layouts.</strong></p><li><p><strong>Don't over comment.</strong></p></ul></article></main><aside class=blur><nav><ul><li><a class=toc-h2 href=#introduction>Introduction</a><li><a class=toc-h2 href=#expression>Expression</a><li><a class=toc-h2 href=#control-structure>Control structure</a><li><a class=toc-h2 href=#program-structure>Program structure</a><li><a class=toc-h2 href=#input-and-output>Input and output</a><li><a class=toc-h2 href=#common-blunders>Common blunders</a><li><a class=toc-h2 href=#efficiency>Efficiency</a><li><a class=toc-h2 href=#documentation>Documentation</a></ul></nav><a aria-label="back to top" href=#top id=back-to-top><i class="ri-arrow-up-s-line ri-2x"></i></a></aside></div><footer><div class=copyright>i don't believe in copyright</div></footer><script src=/js/dark.js></script><script src=/js/toc.js></script><script src=/js/progress.js></script><script src=/js/lightense.min.js></script><script src=/js/img.js></script>